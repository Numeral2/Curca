<!DOCTYPE html>
<html lang="hr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Parking Igra - Prava Fizika</title>
    <!-- Import the Inter font from Google Fonts -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;700&display=swap" rel="stylesheet">
    <!-- Import the physics engine, Matter.js -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/matter-js/0.18.0/matter.min.js"></script>
    <style>
        /* Basic styles for the page */
        body, html {
            height: 100%;
            margin: 0;
            padding: 0;
            overflow: hidden;
            font-family: 'Inter', sans-serif;
            background-color: #f0f2f5;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            touch-action: none; /* Prevents scrolling on mobile */
        }

        /* Container for the entire game interface */
        #game-container {
            width: 100%;
            max-width: 500px; /* Max width for larger screens */
            height: 100%;
            max-height: 800px;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
            align-items: center;
            background-color: #fff;
            box-shadow: 0 10px 25px rgba(0,0,0,0.1);
            border-radius: 20px;
            overflow: hidden;
            position: relative;
        }

        /* Styles for the game canvas where the action happens */
        #game-canvas {
            width: 100%;
            flex-grow: 1;
            position: relative;
        }
        
        canvas {
            display: block;
            width: 100%;
            height: 100%;
        }

        /* Styles for the control area at the bottom */
        #controls {
            width: 100%;
            padding: 20px;
            display: flex;
            justify-content: space-around;
            align-items: center;
            background-color: #e9ebee;
            box-sizing: border-box;
            user-select: none; /* Prevents text selection on controls */
        }

        /* Styles for the Gas and Brake pedals */
        .pedal {
            width: 70px;
            height: 100px;
            border-radius: 15px;
            display: flex;
            justify-content: center;
            align-items: center;
            font-weight: bold;
            font-size: 18px;
            color: white;
            cursor: pointer;
            box-shadow: 0 5px 15px rgba(0,0,0,0.2), inset 0 -4px 0 rgba(0,0,0,0.2);
            transition: all 0.1s ease;
        }

        .pedal:active {
            transform: translateY(2px);
            box-shadow: 0 2px 5px rgba(0,0,0,0.2), inset 0 -2px 0 rgba(0,0,0,0.1);
        }

        #gas { background-color: #4CAF50; }
        #brake { background-color: #F44336; }

        /* --- Realistic Steering Wheel Style --- */
        #steering-wheel-container {
            width: 150px;
            height: 150px;
            position: relative;
            display: flex;
            justify-content: center;
            align-items: center;
        }

        #steering-wheel {
            width: 140px;
            height: 140px;
            border-radius: 50%;
            background-image: radial-gradient(circle, #5a5a5a, #333);
            border: 6px solid #222;
            position: relative;
            cursor: grab;
            box-shadow: 0 8px 15px rgba(0,0,0,0.3), inset 0 0 10px rgba(0,0,0,0.5);
        }
        
        #steering-wheel:active { cursor: grabbing; }

        #steering-wheel .horn {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 50px;
            height: 50px;
            background-image: radial-gradient(circle, #777, #555);
            border-radius: 50%;
            border: 4px solid #444;
            box-shadow: 0 2px 4px rgba(0,0,0,0.4);
            z-index: 2;
        }
        
        .spoke {
            position: absolute;
            background-color: #444;
            box-shadow: 0 1px 2px rgba(0,0,0,0.3);
            top: 50%;
            left: 50%;
            width: 12px;
            height: 110%;
            transform-origin: center;
        }
        .spoke.spoke-1 { transform: translate(-50%, -50%) rotate(0deg); }
        .spoke.spoke-2 { transform: translate(-50%, -50%) rotate(120deg); }
        .spoke.spoke-3 { transform: translate(-50%, -50%) rotate(240deg); }

        /* Message overlay */
        #message-overlay {
            position: absolute;
            top: 0; left: 0;
            width: 100%; height: 100%;
            background-color: rgba(0, 0, 0, 0.7);
            color: white;
            display: flex;
            justify-content: center;
            align-items: center;
            text-align: center;
            font-size: 1.5em;
            flex-direction: column;
            z-index: 100;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.5s ease;
        }
        
        #message-overlay.visible { opacity: 1; pointer-events: all; }
        #message-content h2 { margin-bottom: 25px; }
        #message-content button {
            margin: 8px;
            padding: 12px 25px;
            font-size: 0.6em;
            border: none;
            border-radius: 10px;
            background-color: #4CAF50;
            color: white;
            cursor: pointer;
            font-weight: bold;
            text-transform: uppercase;
            transition: background-color 0.2s;
        }
        #message-content button:hover { background-color: #45a049; }
        #play-again-button { background-color: #008CBA; }
        #play-again-button:hover { background-color: #007ba7; }

    </style>
</head>
<body>

    <div id="game-container">
        <div id="game-canvas">
            <div id="message-overlay">
                <div id="message-content">
                    <h2 id="message-title"></h2>
                    <p id="message-text"></p>
                    <div id="level-selection">
                        <button class="level-select-button" data-level="1">Nivo 1: Okomito (Lijevo)</button>
                        <button class="level-select-button" data-level="2">Nivo 2: Okomito (Desno)</button>
                    </div>
                    <button id="play-again-button" style="display: none;">Igraj Ponovo</button>
                </div>
            </div>
        </div>
        <div id="controls">
            <div id="brake" class="pedal">KOČNICA</div>
            <div id="steering-wheel-container">
                <div id="steering-wheel">
                    <div class="spoke spoke-1"></div>
                    <div class="spoke spoke-2"></div>
                    <div class="spoke spoke-3"></div>
                    <div class="horn"></div>
                </div>
            </div>
            <div id="gas" class="pedal">GAS</div>
        </div>
    </div>

    <script>
        // --- MODULE-LEVEL VARIABLES ---
        const { Engine, Render, Runner, World, Bodies, Body, Events, Vector, Bounds } = Matter;
        const gameCanvas = document.getElementById('game-canvas');
        const messageOverlay = document.getElementById('message-overlay');
        const messageTitle = document.getElementById('message-title');
        const messageText = document.getElementById('message-text');
        const levelSelectionContainer = document.getElementById('level-selection');
        const playAgainButton = document.getElementById('play-again-button');
        const steeringWheel = document.getElementById('steering-wheel');

        let engine, render, runner, car, goal;
        let gasOn = false, brakeOn = false, gameOver = false;
        let currentLevel = 1;

        // --- REALISTIC STEERING MECHANICS VARIABLES ---
        let isDraggingWheel = false;
        let wheelTotalRotation = 0;
        let lastPointerAngle = 0;
        const MAX_WHEEL_ROTATION = 540; // 1.5 turns each way
        let physicsSteeringAngle = 0; // Normalized value (-1 to 1) for physics

        // --- INITIALIZATION ---
        function initGame(level) {
            gameOver = false;
            gasOn = false; brakeOn = false;
            wheelTotalRotation = 0; physicsSteeringAngle = 0;
            updateSteeringWheelVisual();
            messageOverlay.classList.remove('visible');

            engine = Engine.create();
            engine.world.gravity.y = 0;

            const canvasWidth = gameCanvas.clientWidth;
            const canvasHeight = gameCanvas.clientHeight;
            render = Render.create({
                element: gameCanvas,
                engine: engine,
                options: { width: canvasWidth, height: canvasHeight, wireframes: false, background: '#dce4f0' }
            });

            // --- CREATE GAME OBJECTS ---
            const carWidth = 40, carHeight = 80;
            
            goal = Bodies.rectangle(canvasWidth / 2, canvasHeight * 0.8, carWidth + 10, carHeight + 10, { 
                isSensor: true, isStatic: true,
                render: { fillStyle: 'rgba(241, 196, 15, 0.4)', strokeStyle: 'rgba(241, 196, 15, 1)', lineWidth: 2 } // Yellow
            });

            const obstacle1 = Bodies.rectangle(goal.position.x - 65, goal.position.y, carWidth, carHeight, { 
                isStatic: true, render: { fillStyle: '#95a5a6' } // Gray
            });
            const obstacle2 = Bodies.rectangle(goal.position.x + 65, goal.position.y, carWidth, carHeight, { 
                isStatic: true, render: { fillStyle: '#95a5a6' } // Gray
            });
            
            const carInitialY = canvasHeight * 0.4;
            const carInitialX = (level === 1) ? canvasWidth * 0.25 : canvasWidth * 0.75;
            const carInitialAngle = (level === 1) ? Math.PI / 2 : -Math.PI / 2;

            car = Bodies.rectangle(carInitialX, carInitialY, carWidth, carHeight, {
                angle: carInitialAngle, frictionAir: 0.08, friction: 0.1, restitution: 0.2,
                render: { visible: false } 
            });
            
            const wallThickness = 40;
            const walls = [
                Bodies.rectangle(canvasWidth / 2, -wallThickness / 2, canvasWidth, wallThickness, { isStatic: true }),
                Bodies.rectangle(canvasWidth / 2, canvasHeight + wallThickness / 2, canvasWidth, wallThickness, { isStatic: true }),
                Bodies.rectangle(-wallThickness / 2, canvasHeight / 2, wallThickness, canvasHeight, { isStatic: true }),
                Bodies.rectangle(canvasWidth + wallThickness / 2, canvasHeight / 2, wallThickness, canvasHeight, { isStatic: true })
            ];
            walls.forEach(wall => wall.render.visible = false);

            World.add(engine.world, [car, goal, obstacle1, obstacle2, ...walls]);

            Render.run(render);
            runner = Runner.create();
            Runner.run(runner, engine);

            Events.on(engine, 'beforeUpdate', onBeforeUpdate);
            Events.on(engine, 'collisionStart', onCollision);
            Events.on(render, 'afterRender', drawCarDetails);
        }
        
        function cleanupGame() {
            if (runner) Runner.stop(runner);
            if (render) {
                Events.off(render, 'afterRender', drawCarDetails);
                Render.stop(render);
            }
            if (engine) {
                World.clear(engine.world);
                Engine.clear(engine);
                Events.off(engine, 'beforeUpdate', onBeforeUpdate);
                Events.off(engine, 'collisionStart', onCollision);
            }
            if (render && render.canvas) render.canvas.remove();
        }

        // --- GAME LOOP & PHYSICS ---
        function onBeforeUpdate() {
            if (gameOver) return;

            // --- Apply forces for Gas and Brake ---
            const moveForce = 0.002;
            const brakeForce = 0.001;
            if (gasOn) Body.applyForce(car, car.position, Vector.rotate(Vector.create(0, -moveForce), car.angle));
            if (brakeOn) Body.applyForce(car, car.position, Vector.rotate(Vector.create(0, car.speed > 1.5 ? moveForce : brakeForce), car.angle));

            // --- NEW: REALISTIC STEERING LOGIC ---
            const carSpeed = car.speed;
            if (carSpeed > 0.1) {
                // 1. Determine direction of travel (forward or reverse)
                const forwardVector = Vector.rotate(Vector.create(0, -1), car.angle);
                const dotProduct = Vector.dot(car.velocity, forwardVector);
                const isReversing = dotProduct < 0;

                // 2. Calculate base turning force
                const turnSensitivity = 0.02;
                let turnAngle = physicsSteeringAngle * turnSensitivity * (carSpeed / 3);

                // 3. Invert turning direction if in reverse
                if (isReversing) {
                    turnAngle *= -1;
                }

                // 4. Apply angular velocity
                Body.setAngularVelocity(car, turnAngle);
            } else {
                 Body.setAngularVelocity(car, 0);
            }
            
            checkWinCondition();
        }
        
        // --- CUSTOM CAR & WHEEL RENDERING ---
        function drawCarDetails() {
            const ctx = render.context;
            const pos = car.position;
            const angle = car.angle;
            const carWidth = 40, carHeight = 80;

            ctx.save();
            ctx.translate(pos.x, pos.y);
            ctx.rotate(angle);

            ctx.fillStyle = gameOver ? '#a04040' : '#e74c3c'; // Red car
            ctx.fillRect(-carWidth / 2, -carHeight / 2, carWidth, carHeight);
            
            ctx.fillStyle = '#aaddff';
            ctx.fillRect(-carWidth/2 + 5, -carHeight/2 + 5, carWidth - 10, 20);

            const wheelWidth = 8, wheelHeight = 18;
            const wheelXOffset = carWidth / 2, wheelYOffset = carHeight / 3;
            const frontWheelAngle = physicsSteeringAngle * (Math.PI / 6);

            drawWheel(ctx, -wheelXOffset, wheelYOffset, wheelWidth, wheelHeight, 0);
            drawWheel(ctx, wheelXOffset, wheelYOffset, wheelWidth, wheelHeight, 0);
            drawWheel(ctx, -wheelXOffset, -wheelYOffset, wheelWidth, wheelHeight, frontWheelAngle);
            drawWheel(ctx, wheelXOffset, -wheelYOffset, wheelWidth, wheelHeight, frontWheelAngle);

            ctx.restore();
        }

        function drawWheel(ctx, x, y, width, height, angle) {
            ctx.save();
            ctx.translate(x, y);
            ctx.rotate(angle);
            ctx.fillStyle = '#333';
            ctx.fillRect(-width / 2, -height / 2, width, height);
            ctx.restore();
        }

        // --- WIN/LOSS & UI ---
        function checkWinCondition() {
            const isInside = Bounds.overlaps(car.bounds, goal.bounds);
            const normalizedCarAngle = (car.angle % Math.PI + Math.PI) % Math.PI;
            const angleDiff = Math.abs(normalizedCarAngle);
            const isAligned = angleDiff < 0.15 || (Math.PI - angleDiff) < 0.15;
            const isStopped = car.speed < 0.05 && Math.abs(car.angularVelocity) < 0.05;

            if (isInside && isAligned && isStopped) endGame(true);
        }

        function onCollision(event) {
            if (gameOver) return;
            for (const pair of event.pairs) {
                if ((pair.bodyA === car || pair.bodyB === car) && !pair.isSensor) {
                    if (pair.collision.depth > 1) {
                        endGame(false);
                        break;
                    }
                }
            }
        }
        
        function showStartScreen() {
            cleanupGame();
            messageTitle.textContent = 'Parking Izazov';
            messageText.textContent = 'Odaberi stranu za početak.';
            levelSelectionContainer.style.display = 'block';
            playAgainButton.style.display = 'none';
            messageOverlay.classList.add('visible');
        }

        function endGame(isWin) {
            if (gameOver) return;
            gameOver = true;
            Runner.stop(runner);
            messageTitle.textContent = isWin ? 'Majstorski Parkirano!' : 'Ups! Sudar!';
            messageText.textContent = isWin ? 'Svaka čast!' : 'Više sreće drugi put.';
            levelSelectionContainer.style.display = 'none';
            playAgainButton.style.display = 'inline-block';
            messageOverlay.classList.add('visible');
        }
        
        function resetGame() {
            cleanupGame();
            initGame(currentLevel);
        }

        // --- EVENT LISTENERS & STEERING LOGIC ---
        function setupEventListeners() {
            steeringWheel.addEventListener('mousedown', handleDragStart);
            steeringWheel.addEventListener('touchstart', handleDragStart, { passive: false });
            window.addEventListener('mouseup', handleDragEnd);
            window.addEventListener('touchend', handleDragEnd);
            window.addEventListener('mousemove', handleDragMove);
            window.addEventListener('touchmove', handleDragMove, { passive: false });

            const gasPedal = document.getElementById('gas');
            const brakePedal = document.getElementById('brake');
            ['mousedown', 'touchstart'].forEach(evt => {
                gasPedal.addEventListener(evt, e => { e.preventDefault(); gasOn = true; });
                brakePedal.addEventListener(evt, e => { e.preventDefault(); brakeOn = true; });
            });
            ['mouseup', 'mouseleave', 'touchend'].forEach(evt => {
                gasPedal.addEventListener(evt, () => gasOn = false);
                brakePedal.addEventListener(evt, () => brakeOn = false);
            });
            
            document.querySelectorAll('.level-select-button').forEach(button => {
                button.addEventListener('click', () => {
                    currentLevel = parseInt(button.dataset.level, 10);
                    resetGame();
                });
            });
            playAgainButton.addEventListener('click', resetGame);
            window.addEventListener('resize', () => { engine ? resetGame() : showStartScreen(); });
        }
        
        function getPointerAngle(e) {
            const rect = steeringWheel.getBoundingClientRect();
            const centerX = rect.left + rect.width / 2;
            const centerY = rect.top + rect.height / 2;
            const clientX = e.touches ? e.touches[0].clientX : e.clientX;
            const clientY = e.touches ? e.touches[0].clientY : e.clientY;
            return Math.atan2(clientY - centerY, clientX - centerX) * 180 / Math.PI;
        }

        function handleDragStart(e) {
            e.preventDefault();
            isDraggingWheel = true;
            steeringWheel.style.cursor = 'grabbing';
            lastPointerAngle = getPointerAngle(e);
        }

        function handleDragMove(e) {
            if (!isDraggingWheel) return;
            e.preventDefault();
            const currentPointerAngle = getPointerAngle(e);
            let deltaAngle = currentPointerAngle - lastPointerAngle;
            if (deltaAngle > 180) deltaAngle -= 360;
            if (deltaAngle < -180) deltaAngle += 360;
            wheelTotalRotation = Math.max(-MAX_WHEEL_ROTATION, Math.min(MAX_WHEEL_ROTATION, wheelTotalRotation + deltaAngle));
            physicsSteeringAngle = wheelTotalRotation / MAX_WHEEL_ROTATION;
            lastPointerAngle = currentPointerAngle;
            updateSteeringWheelVisual();
        }

        function handleDragEnd() {
            isDraggingWheel = false;
            steeringWheel.style.cursor = 'grab';
        }
        
        function updateSteeringWheelVisual() {
            steeringWheel.style.transform = `rotate(${wheelTotalRotation}deg)`;
        }

        // --- START THE GAME ---
        document.addEventListener('DOMContentLoaded', () => {
            setupEventListeners();
            showStartScreen();
        });
    </script>
</body>
</html>
